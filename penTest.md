# 前端笔试题

 [TOC]

## 请写出下列代码的打印顺序

````js {.font}
var name = 'global';
var obj = {
    name: 'local',
    foo: function(){
        this.name = 'foo';
    }.bind(window)
};
var bar = new obj.foo();
setTimeout(function() {
    console.log(window.name);
}, 0);
console.log(bar.name);
var bar3 = bar2 = bar;
bar2.name = 'foo2';
console.log(bar3.name);
````

>>解析：
    1、输出顺序主要考察：Event Loop；
    2、第一个和第三个输出考察：this指针；
    3、第二个输出考察：引用类型赋值

  ````js {.font}
  var name = 'global';
    var obj = {
        name: 'local',
        foo: function(){
            console.log(this)
            this.name = 'foo';
        }.bind(window)
    };
    console.log(obj.foo());// 此时调用的this是window
    // 由于new绑定的优先级大于bind绑定，所以函数内部this还是obj {}
    var bar = new obj.foo();
    console.log(bar);//{name：'foo'}
    console.log(window.name);//global

    // 定时器任务，在最后放入任务队列，window对象没有被改变，所以输出 'global'
    setTimeout(function() {
        console.log(window.name);
    }, 0);
    // 此时bar.name =foo,因为被赋值了
    console.log(bar.name);
        
    // 此时执行顺序是var bar3,bar2=bar,bar3=bar2, 所以bar3/bar2/bar都是指向同一个对象
    var bar3 = bar2 = bar;
    bar2.name = 'foo2';
    // 所以bar2修改属性，bar3的也改变了，此时输出为'foo2'
    console.log(bar3.name);
  ````  

## 请写出下面ES6代码编译后所生成的ES5代码

````js {.font}
class Person {
    constructor (name) {
        this.name = name;
    }
    greet () {
        console.log(`Hi, my name is ${this.name}`);
    }
    greetDelay (time) {
        setTimeout(() => {
            console.log(`Hi, my name is ${this.name}`);
        }, time);
    }
}
````

>>解析：
   1、class语法糖
   2、模板字符串
   3、setTimeout中的this问题
   4、箭头函数中的this问题

````js {.font}
 fucntion Person(name){
     this.name=name;
 }
 Person.prototype.greet=function(){
    console.log('Hi, my name is'+this.name);
 }
 Person.prototype.greetDelay=function(time){
     var _this=this;
     setTimeout(
     fucntion(){
         console.log('Hi, my name is' _this.name);
     },time);   
 }
````

## 排序算法

## JS中创建节点的方式有哪些？

- Document.createElement()
- var dupNode = node.cloneNode(deep);
  >>
 <dl>
 <dt id="node"><code>node</code></dt>
 <dd>将要被克隆的节点</dd>
 <dt id="dupnode"><code>dupNode</code></dt>
 <dd>克隆生成的副本节点</dd>
 <dt id="deep"><code>deep</code> 可选</span></dt>
 <dd>是否采用深度克隆，如果为 <code>true</code>，则该节点的所有后代节点也都会被克隆，如果为 <code>false</code>，则只克隆该节点本身。</dd>
</dl>

## redux三大原则

<ul><li>
单一数据源
    <ul><li>整个应用程序的<span style='color:#fe2c24;'>state</span>只存储在<span style='color:#fe2c24;'>一个&nbsp;store</span>&nbsp;中</li><li>Redux并没有强制让我们不能创建多个Store，但是那样做并不利于数据的维护</li><li>单一的数据源可以让整个应用程序的state变得方便维护、追踪、修改</li></ul></li><li>
State是只读的
    <ul><li>唯一<span style='color:#fe2c24;'>修改State</span>的方法一定是<span style='color:#fe2c24;'>触发action</span>，不要试图在其他地方通过任何的方式来修改State</li><li>这样就确保了View或网络请求都不能直接修改state，它们只能通过action来描述自己想要如何修改stat；</li><li>这样可以保证所有的修改都被集中化处理，并且按照严格的顺序来执行，所以不需要担心race&nbsp;condition（竟态）的问题；</li></ul></li><li>
使用
<span style='color:#fe2c24;'>纯函数(返回结果只依赖于它的参数，并且在执行过程里面没有副作用)</span>来执行修改
    <ul><li>通过reducer将&nbsp;旧state和&nbsp;action联系在一起，并且返回一个新的State：</li><li>随着应用程序的复杂度增加，我们可以将reducer拆分成多个小的reducers，分别操作不同state&nbsp;tree的一部分</li><li>但是所有的reducer都应该是纯函数，不能产生任何的副作用</li></ul></li></ul>

## 下段代码打印结果为

````js {.font}
const Person = (name="wang",age=10) => {
this.name = name;
this.age = age;
return this.name +' is '+ this.age + 'years old'
}
let result = new Person('zhang',11)
console.log(result)
````

正解：**箭头函数不能作为构造函数使用**，所以函数执行会报错

## JavaScript中，字符串与数组有许多相同的方法，以下不属于的是

- slice
- indexOf
- reverse
- concat

正解：字符串没有内置的reverse方法，可用`str.split("").reverse().join("")` 代替

## 以下哪些ul的height不是0

````js {.font}
A：  <ul style="overflow: hidden;"> 
      <li style="float: left">1</li> 
     </ul> 
  
B：  <ul style="float: left;"> 
      <li style="float:left;">1</li> 
     </ul> 

C：  <ul style="clear: both;"> 
      <li style="float: left">1</li> 
     </ul> 
````

正解:AB

- A选项：overflow：hidden 产生BFC，可以防止元素塌陷
- B选项： float：left也产生BFC，可以防止元素塌陷
- C选项：clear：both，属性应该加载父级元素的最后一个子元素上，而不是加载父元素上

## 以下表达式，正确的是

正确答案: D   你的答案: B (错误)

A &nbsp;&nbsp;Number('a') == Number('a')
B &nbsp;&nbsp;-1 == true
C &nbsp;&nbsp;3 + '2' === 5
D &nbsp;&nbsp;![] == ''

js在**转换布尔值**时候将：0、null、false、NaN、undefined、'' 转为false，其他所有数据都转换为true

注意：会将参数*转换为布尔值的情况有：！、if()、A?B:C*；***在==类型转换时，并不会将数据转为布尔值***

思考：

````js {.font}
判断：![]==[];
      null==false;
      undefined==false;
      []==false;
      NaN==false;
````

## 下列创建的对象中，打印的值分别为多少？

````js {.font}
var a={}, b='123', c=123;
a[b]='b';
a[c]='c';
console.log(a[b]);  //==>c

var a={}, b=Symbol('123'), c=Symbol('123');
a[b]='b';
a[c]='c';
console.log(a[b]); //==>b

var a={}, b={key:'123'}, c={key:'456'};
a[b]='b';
a[c]='c';
console.log(a[b]); //==>c
````

**属性访问器**提供了两种方式用于访问一个对象的属性，它们分别是**点号和方括号**，对象的**属性名**可以是任意的**字符串**或**Symbol**。其它类型会被**自动转换成字符串
>>转换为字符串规则：
1、对象：**进行\[Symbol.toPrimitive]()\==>valuOf()\==>toString()**
2、非对象：**String()**

1、(.) 点操作符: 静态的。右侧必须是一个以**属性名称命名的简单标识符**
2、([]) 中括号操作符: 动态的；方括号里必须是一个计算结果为字符串的表达式，可以是变量、字符串、数字、表达式(或Symbol值·了解)

## 关于transition

正解：若**过渡起始值为auto**，**不发生过渡效果**。所以要过渡某些属性，首先需要将其重置成具体数字值

## 关于\<input type="text" /> change 事件和input事件描述最准确的是？

正解：用户键入内容改变时，触发input事件，且在当标签失焦后，触发change事件

## CSS 中，top 属性是那两个部分的距离？

正解：top样式属性定义了定位元素的**上外边距边界**与其包含块上边界(border-top)之间的偏移

## 5 % 6===5

## 怎样完美实现左右定宽，section自适应尺寸的布局

````js {.font}
方式一: <div> 
        <div class="right" /> 
        <div class="left" /> 
        <div class="section"/> 
        </div> 
     
     .content {
            height: 400px;
            background: #f90;
            width: 100%;
        }
        .left {
            width: 300px;
            height: 400px;
            background: purple;
            float: right;
        }
        .right {
            width: 300px;
            height: 400px;
            background: palevioletred;
            float: left;
        }


方式二:    <div style="display:flex"> 
            <div style="height: 100px;width: 100px;"></div> 
            <div style="flex:1"> </div>
            <div style="height: 100px;width: 100px;"></div>
          </div>
````

## 执行下面的代码，执行后，5S内点击两下，过了5S后，再点击两下，整个过程的输出结果是什么？

````js {.font}
setTimeout(function () {
  for (let i = 0; i < 1000; i++) {}
  console.log('timer a');
}, 0);

for (let j = 0; j < 5; j++) {
  console.log(j);
}

setTimeout(function () {
  console.log('timer b');
}, 0);

function waitFiveSeconds() {
  let now = (new Date()).getTime();
  while (((new Date()).getTime() - now) < 5000) {}
  console.log('finished waiting');
}

document.addEventListener('click', function () {
  console.log('click');
});

console.log('click begin');
waitFiveSeconds();
````

## 写出下方代码打印顺序

````js {.font}
console.log('start');
setTimeout(() => console.log('s1') , 0);
new Promise((resolve) => {
  console.log('p1');
  resolve()
}).then(v => {
  console.log('t1');
  setTimeout(() => { console.log('s2') }, 0);
  new Promise((resolve) => {
    console.log('p2');
    resolve()
  }).then(v => {
    console.log('t2')
  });
  console.log('t3');
  setTimeout(() => { console.log('s3') }, 0);
});
console.log('end');

````

为什么学前端*4

## 实现边长自适应的正方形

- 方法一,灵活运用视窗单位*vw*。当**没给body设置css**时，**body的width为100vw，height为0**，即说明当一个元素以body为父元素时，**width：n%与width：nvw等价**，**height：n%与height: nvh等价且都等于0**
  
````css
#square{  
    width:30vw;  
    height:30vw;  
    background:red;  
}
或者
#square{  
    width:30%;  
    height:30vw;  
    background:red;  
}
  ````

- 方法二，设置垂直方向的padding撑开容器。如果给子**元素的padding属性设置为 %**，无论上下左右方向，则其**基数都取决于父元素的width属性。**

 ````css
#square{  
    width:30%;  
    padding-bottom: 100%;  或者padding-top：30%
    background:red;  
}
````

- 方法三，利用伪元素的 margin(padding)-top 撑开容器（::after用来创建一个伪元素，作为已选中元素的最后一个**子元素**）

>>为什么加*overflow：hidden*：在**垂直方向**上，当**子元素的margin与父元素的border相邻时**，**子元素的margin会贯穿父元素，变成父元素的margin**==>margin贯穿，是父元素形成一个BFC可避免这一现象，或者使用padding代替margin

````css
#square{
    width:30%;
    background:red;
    overflow:hidden;
}
#square:after{
    content: '';
    display: block;
    margin-top:100%;  使用padding-top则不需要触发BFC
}
````

虚拟dom怎样渲染上去的

## v-if VS v-show

- v-if 是“真实的”按条件渲染，因为它确保了**在切换时，条件区块内的事件监听器和子组件都会被销毁与重建**

- v-if 也是惰性的：如果在初次渲染时条件值为 false，则不会做任何事。条件区块只有当条件首次变为 true 时才被渲染。

- 相比之下，**v-show 简单许多，元素无论初始条件如何，始终会被渲染，只有 CSS display 属性会被切换**。

- 总的来说，**v-if 有更高的切换开销**，而 v-show 有更高的初始渲染开销。**因此，如果需要频繁切换，则使用 v-show 较好**；如果在运行时绑定条件很少改变，则 v-if 会更合适

## \<style scoped\>中的scoped的作用是？原理是？加和不加的区别？

js 与 ts 区别
前端框架里面的key
跨域
事件委托

虚拟dom的好处，以及虚拟dom的本质

## 箭头函数与普通函数的区别

箭头函数中的this问题
为什么不能用call aplly bind来改变箭头函数的this指向
定时请求数据出错
大屏展示界面的适配
如何把ts jsx vue转换成浏览器能识别的
css用了哪些单位